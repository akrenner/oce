/* vim: set expandtab shiftwidth=2 softtabstop=2 tw=70: */

// Comments like //t3 refer to trial t3 in git/oce-issues/18xx/1880/README.md

#include <Rcpp.h>
using namespace Rcpp;

// Cross-reference work:
// 1. update ../src/registerDynamicSymbol.c with an item for this
// 2. main code should use the autogenerated wrapper in ../R/RcppExports.R

//#define USE_APPROX_EXP 1
#ifdef USE_APPROX_EXP
// Compute exp(-x) approximately, as efficiency measure.
// See Dan Kelley notebook [1997/1/25] for demonstration
// of factor of 3 speedup, with 1000 column data and a
// 10 by 10 grid, and demonstration that the
// error is < 0.1% in the final grid.
inline double exp_approx(double x)
{
  return 1.0 / (0.999448
      + x * (1.023820
        + x * (0.3613967
          + x * (0.4169646
            + x * (-0.1292509
              + x * 0.0499565)))));
}
#endif

static double interpolate_barnes(double xx, double yy, double zz, /* interpolate to get zz value at (xx,yy) */
    int skip, /* value in (x,y,z) to skip, or -1 if no skipping */
    unsigned int nx, double *x, double *y, double *z, double *w, /* data num, locations, values, weights */
    double *z_last, /* last estimate of z at (x,y) */
    double xr, double yr) /* influence radii */
{
  double sum = 0.0, sum_w = 0.0;
  double dx, dy, d, weight;
  for (unsigned int k = 0; k < nx; k++) {
    // R trims NA (x,y values so no need to check here
    if ((int)k != skip) {
      dx = (xx - x[k]) / xr;
      dy = (yy - y[k]) / yr;
      d = dx*dx + dy*dy;
#ifdef USE_APPROX_EXP
      weight = w[k] * exp_approx(-d);
#else
      weight = w[k] * exp(-d);
#endif
      sum += weight * (z[k] - z_last[k]);
      sum_w += weight;
    }
  }
  return ((sum_w > 0.0) ? (zz + sum / sum_w) : NA_REAL);
}

// next is modelled on interpolate_barnes()
static double weight_barnes(double xx, double yy,
    int skip,
    unsigned int n, double *x, double *y, double *z, double *w,
    double xr, double yr)
{
  double sum_w = 0.0, dx, dy, d, weight;
  for (unsigned int k = 0; k < n; k++) {
    if ((int)k != skip) {
      dx = (xx - x[k]) / xr;
      dy = (yy - y[k]) / yr;
      d = dx*dx + dy*dy;
#ifdef USE_APPROX_EXP
      weight = w[k] * exp_approx(-d);
#else
      weight = w[k] * exp(-d);
#endif
      sum_w += weight;
    }
  }
  return ((sum_w > 0.0) ? sum_w : NA_REAL);
}


// [[Rcpp::export]]
List do_interp_barnes(NumericVector x, NumericVector y, NumericVector z, NumericVector w,
    NumericVector xg, NumericVector yg,
    NumericVector xr, NumericVector yr,
    NumericVector gamma, NumericVector iterations)
{
  int nx = x.size();
  int nxg = xg.size();
  int nyg = yg.size();
  double rgamma = gamma[0]; // gamma
  if (rgamma < 0.0)
    ::Rf_error("cannot have gamma < 0, but got gamma=%f", rgamma);
  int niter = floor(0.5 + iterations[0]); // number of iterations
  if (niter < 1)
    ::Rf_error("cannot have fewer than 1 iteration, but got niter=%d ", niter);
  if (niter > 20)
    ::Rf_error("cannot have more than 20 iterations, but got niter=%d ", niter);
  if (xr[0] <= 0)
    ::Rf_error("cannot have xr<=0 but got xr=%f", xr[0]);
  if (yr[0] <= 0)
    ::Rf_error("cannot have yr<=0 but got yr=%f", yr[0]);
  double xr2 = xr[0]; // local radius, which will vary with iteration
  double yr2 = yr[0]; // local radius, which will vary with iteration
  // Get storage
  NumericMatrix zg(nxg, nyg); // predictions on grid
  NumericMatrix wg(nxg, nyg); // weights on the grid
  NumericVector zd(nx);       // predictions at the data
  NumericVector z_last(nx);   // previous (last) values at data points
  NumericMatrix zz(nxg, nyg); // working matrix on grid
  // initialize storage to 0.  I don't know if this is needed, because
  // https://teuder.github.io/rcpp4everyone_en/080_vector.html
  // implies not, but without saying so explicitly.
  std::fill(zz.begin(), zz.end(), 0.0);
  std::fill(z_last.begin(), z_last.end(), 0.0);

  //t3 double *zzp = &zz[0];
  for (int iter = 0; iter < niter; iter++) {
    //Rprintf("iter=%d xr2=%f yr2=%f\n", iter, xr2, yr2);
    /* update grid */
    for (int i = 0; i < nxg; i++) {
      for (int j = 0; j < nyg; j++) {
        //t3 *(zzp+i+j*nxg) = interpolate_barnes(xg[i], yg[j], *(zzp+i+j*nxg),
        zz(i, j) = interpolate_barnes(xg[i], yg[j], zz(i, j),
            -1, /* no skip */
            nx, &x[0], &y[0], &z[0], &w[0], &z_last(0),
            xr2, yr2);
      }
      R_CheckUserInterrupt();
    }
    /* interpolate grid back to data locations */
    for (int k = 0; k < nx; k++) {
      //Rprintf("  zd[%d] = %f (iter %d)\n", k, zd[k], iter);
      zd[k] = interpolate_barnes(x[k], y[k], z_last[k],
          -1, /* BUG: why not skip? */
          nx, &x[0], &y[0], &z[0], &w[0], &z_last(0),
          xr2, yr2);
      //Rprintf("  -> zd[%d] = %f (iter %d)\n", k, zd[k], iter);
    }
    R_CheckUserInterrupt();
    // Note that we have to clone, or the final z_last results will be wrong.
    // I think the error stems from Rcpp using pointers sometimes,
    // although I don't see any reason to figure this out, since clone
    // seems to be the recommended approach, in the quickref at
    // https://cran.r-project.org/web/packages/Rcpp/vignettes/Rcpp-quickref.pdf
    for (int k = 0; k < nx; k++)
      z_last[k] = zd[k];
    //t5 z_last = clone(zd);

    if (rgamma > 0.0) {
      // refine search range for next iteration
      xr2 *= sqrt(rgamma);
      yr2 *= sqrt(rgamma);
    }
  }

  // copy matrix to return value
  for (int i = 0; i < nxg; i++)
    for (int j = 0; j < nyg; j++)
      zg(i, j) = zz(i, j);
  //t5 zg = clone(zz);

  // weights at final region-of-influence radii
  for (int i = 0; i < nxg; i++) {
    for (int j = 0; j < nyg; j++) {
      wg(i, j) = weight_barnes(xg[i], yg[j],
          -1, /* no skip */
          nx, &x[0], &y[0], &z[0], &w[0],
          xr2, yr2);
    }
    R_CheckUserInterrupt();
  }
  return(List::create(Named("zg")=zg, Named("wg")=wg, Named("zd")=zd));
}
